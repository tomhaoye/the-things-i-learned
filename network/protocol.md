# TCP/IP四层模型(此外还有：OSI七层模型、五层英特网模型)

 - 应用层：传递的信息称报文
 - 传输层：负责传输应用的报文，TCP和UDP，包装成新的结构，称为报文段
 - 网络层：将报文段包装成数据报的结构，然后移动到另一台主机
 - 链路层：将数据报包装成'帧'，然后移动到下一节点
 
 链路层
 ---
  - MAC：MAC 地址又称为物理地址、硬件地址，用来定义网络设备的位置。网卡的物理地址通常是由网卡生产厂家写入网卡的，具有全球唯一性。MAC地址用于在网络中唯一标示一个网卡，一台电脑会有一或多个网卡，每个网卡都需要有一个唯一的MAC地址。
  - ARP：地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。
  - RARP：反向地址转换协议，即将局域网中某个主机的物理地址转换为IP地址。注意 ARP 和 RARP 是网络层的协议，但是它们所工作的内容是链路层的。
  
网络层
---
 - 转发：从单一路由器中从一条进入链路到出链路的传送
 - 路由选择：决定数据报从源到目的地的路径
 
 - 地址
    + A类地址：0.0.0.0 ~ 127.255.255.255
    + B类地址：128.0.0.0 ~ 191.255.255.255
    + C类地址：192.0.0.0 ~ 223.255.255.255
    + D类地址：224.0.0.1 ~ 239.255.255.255
    + E类地址：240.0.0.1 ~ 255.255.255.255

 - DHCP：
    1. 广播发送DHCP discover，网络中所有DHCP服务器接收到消息
    2. DHCP服务器回应DHCP offer消息，若不止一台，客户的会选择第一条offer
    3. 广播发送DHCP request，告诉选中的服务器分配的IP，并广播其他服务器不需要再发offer
    4. DHCP服务器回发DHCP ACK进行响应

传输层
---
 - 端口：0 ~ 65535，公认：(0 ~ 1023)
 - 传输层存在的意义?
    + 由于网络层的分组传输是不可靠的，无法了解数据到达终点的时间，无法了解数据未达终点的状态。因此有必要增强网络层提供服务的服务质量。
 - UDP协议：不可靠、（IP协议），速度优势
 
<table>
	<tbody>
		<tr>
			<td>source port</td>
			<td>destination port</td>
		</tr>
		<tr>
			<td>length</td>
			<td>checksum</td>
		</tr>
		<tr>
			<td  colspan="2">message</td>
		</tr>
	</tbody>
</table>

 - UDP与IP传输非常类似，我们为什么不直接使用IP协议而要额外增加一个UDP协议呢？
    + 一个重要的原因是IP协议中并没有端口的概念。IP协议进行的是IP地址到IP地址的传输，这意味者两台计算机之间的对话。但每台计算机中需要有多个通信通道，并将多个通信通道分配给不同的进程使用。一个端口就代表了这样的一个通信通道。正如我们在邮局和邮差中提到的收信人的概念一样。UDP协议实现了端口，从而让数据包可以在送到IP地址的基础上，进一步可以送到某个端口。
    
 - TCP协议：可靠传输\流量控制\拥塞控制
 
<table>
	<tbody>
		<tr>
			<td  colspan="4">source port</td>
			<td  colspan="5">destination port</td>
		</tr>
		<tr>
			<td colspan="9">sequence sum</td>
		</tr>
		<tr>
			<td colspan="9">acknowledgement num</td>
		</tr>
		<tr>
			<td>header len</td>
			<td>unused</td>
			<td>URG</td>
			<td>ACK</td>
			<td>DSH</td>
			<td>RST</td>
			<td>SYN</td>
			<td>FIN</td>
			<td>receive window</td>
		</tr>
		<tr>
			<td  colspan="4">checksum</td>
			<td  colspan="5">urgent data pointer</td>
		</tr>
		<tr>
			<td colspan="9">options</td>
		</tr>
		<tr>
			<td colspan="9">data</td>
		</tr>
	</tbody>
</table>

 - 三次握手的过程？
    + C端标志SYN为1，随机选一个初始序号放入sequence num，然后发送。
    + S端提取SYN，分配缓存，并发送报文，SYN设为1，ACKNOWLEDGEMENT num设为序号＋1，将自己的序号放入sequence num，发送。
    + C端接收后分配缓存与变量，发送确认报文。建立连接，SYN设为0。
 - 四次挥手的过程？
    + C端FIN设为1，发送。
    + S端接收，发送确认报文。
    + S端FIN设为1，发送。
    + C接收，发送确认报文。
    + 进入TIME_WAIT阶段，等待2MSL后S端不再发送报文后才会变成CLOSED状态。
 - TCP协议如何进行流量控制？
    + 利用滑动窗口实现流量控制。发送(Nagle算法)－>接收(delay ack/缓存足够)->返回确认
 - TCP协议如何进行拥塞控制?
    + 慢开始、拥塞避免算法；快重传（三次重复确认）、快恢复（ssthresh，拥避）
    + 路由器丢弃策略：全局同步
 - 什么是粘包？UDP是否也会粘包？
    + TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。从接受与发送上看：
        + TCP默认会使用 Nagle 算法。而 Nagle 算法主要做两件事：1）只有上一个分组得到确认，才会发送下一个分组；2）收集多个小分组，在一个确认到来时一起发送。所以，Nagle 算法可能会造成了发送方粘包现象。
        + TCP接收到分组时，并不会立刻送至应用层处理，或者说，应用层并不一定会立即处理；实际上，TCP将收到的分组保存至接收缓存里，然后应用程序主动从缓存里读收到的分组。这样一来，如果TCP接收分组的速度大于应用程序读分组的速度，多个包就会被存至缓存，应用程序读时，就会读到多个首尾相接粘到一起的包。
    + 从本质上看：
        + TCP协议面向字节流：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。
    + UDP不会发生粘包现象，最主要的原因就是UDP协议是面向报文的，对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送。
 

应用层
---
 - 通信是进程间（不同端系统）的通信
 - socket：应用层与传输层的接口
 
 - DNS：相关命令：nslookup、traceroute
 	+ 根域名服务器
 	+ 顶级域名服务器
 	+ 权限域名服务器
 	+ 本地域名服务器
